##' @title  Read DIA-NN output as a QFeatures objects
##'
##' @description
##'
##' This function takes the output tables from DIA-NN and converts
##' them into a multi-set `QFeatures` object. It is a wrapper around
##' [readQFeatures()] with default parameters set to for DIA-NN
##' label-free and plexDIA report files.
##'
##' @param assayData A `data.frame` or any object that can be coerced
##'     to a data.frame that contains the data from the `Report.tsv`
##'     file generated by DIA-NN.
##'
##' @param colData A `data.frame` or any object that can be coerced to
##'     a `data.frame` containing sample/column annotations. See
##'     [readQFeatures()] for details
##'
##' @param runCol `character(1)` naming the run/batch `assayData`
##'     variable. By default, `"File.Name"`. See [readQFeatures()] for
##'     details.
##'
##' @param extractedData A `data.frame` or any object that can be
##'     coerced to a `data.frame` that contains the data from the
##'     `*_ms1_extracted.tsv` file generated by DIA-NN. This argument
##'     is optional and is currently only applicable for mTRAQ
##'     multiplexed experiments where DIA-NN was run using the
##'     `plexdia` module.
##'
##' @param quantCols A `character(1)` indicating which column in
##'     `assayData` contains the quantitative information. Default is
##'     `"Ms1.Area"`. See [readQFeatures()] for details
##'
##' @param multiplexing A `character(1)` indicating the type of
##'     multiplexing used in the experiment. One of `"none"` (default,
##'     for label-free experiments) or `"mTRAQ"` (for plexDIA
##'     experiments).
##'
##' @param ecol Same as `quantCols` for the single-set case. See
##'     [readQFeatures()] for details
##'
##'
##' @param verbose A `logical(1)` indicating whether the progress of
##'     the data reading and formatting should be printed to the
##'     console. Default is `TRUE`.
##'
##' @param ... Further arguments passed to [readQFeatures()].
##'
##' @return An instance of class `QFeatures`. The quantiative data of
##'     each acquisition run is stored in a separate set as a
##'     `SummarizedExperiment` object.
##'
##' @seealso
##'
##' - The `QFeatures` (see [QFeatures()]) class to read about how to
##'   manipulate the resulting `QFeatures` object.
##'
##' - The [readQFeatures()] function which this one depends on.
##'
##' @author Laurent Gatto, Christophe Vanderaa
##'
##' @importFrom tidyr pivot_wider
##' @importFrom tidyselect all_of
##'
##' @export
##'
##' @examples
##'
##' x <- read.delim(MsDataHub::benchmarkingDIA.tsv())
##' x[["File.Name"]] <- x[["Run"]]
##'
##' #################################
##' ## Label-free multi-set case
##'
##' ## using default arguments
##' readQFeaturesFromDIANN(x)
##'
##' ## with a colData (and default arguments)
##' cd <- data.frame(sampleInfo = LETTERS[1:24],
##'                  quantCols = "Ms1.Area",
##'                  runCol = unique(x[["File.Name"]]))
##' readQFeaturesFromDIANN(x, colData = cd)
##'
##' #################################
##' ## mTRAQ multi-set case
##'
##' ## TODO
readQFeaturesFromDIANN <- function(assayData,
                                   colData = NULL,
                                   quantCols = "Ms1.Area",
                                   runCol = "File.Name",
                                   multiplexing = c("none", "mTRAQ"),
                                   extractedData = NULL,
                                   ecol = NULL,
                                   verbose = TRUE,
                                   ...) {
    multiplexing <- match.arg(multiplexing, several.ok = FALSE)
    if (multiplexing == "mTRAQ") {
        if (verbose) message("Pivoting quantiative data.")
        assayData <- .formatMtraqReportData(assayData, colData,
                                      quantCols, runCol)
        quantCols <- assayData[[2]]
        assayData <- assayData[[1]]
    } ## else is none
    ans <- readQFeatures(assayData, colData = colData,
                         quantCols = quantCols,
                         runCol = runCol,
                         ecol = ecol,
                         ...)
    if (!is.null(extractedData)) {
        ans <- .addDiannExtractedData(ans, extractedData)
    }
    ans
}

## .readQFeaturesFromDIANN <- function(assayData,
##                                    colData = NULL,
##                                    quantCols = "Ms1.Area",
##                                    runCol = "File.Name",
##                                    multiplexing = "none",
##                                    extractedData = NULL,
##                                    ecol = NULL,
##                                    ...) {
##     suppArgs <- .checkDiannArguments(
##         colData, assayData, quantCols, runCol,
##         multiplexing, extractedData, ...)
##     if (multiplexing == "mTRAQ") {
##         assayData <- .formatMtraqReportData(assayData, colData, quantCols)
##     } else if (multiplexing == "none") {
##         colData$quantCols <- quantCols
##     }
##     allArgs <- c(suppArgs, list(
##         assayData = assayData, colData = colData,
##         runCol = runCol, quantCols = quantCols, ...))
##    out <- do.call(readQFeatures, allArgs)
##     if (!is.null(extractedData)) {
##         out <- .addDiannExtractedData(out, extractedData)
##     }
##     out
## }

## Internal function that checks whether the provided arguments match
## the expected input that is generated by DIA-NN.
## Parameter description is the same as for `readSCPfromDIANN()`
## .checkDiannArguments <- function(colData, assayData,
##                                  quantCols, runCol,
##                                  multiplexing, extractedData,
##                                  ...) {
##     diannReportCols <- c("File.Name", "Precursor.Id", "Modified.Sequence")
##     if (!all(diannReportCols %in% colnames(assayData)))
##         stop("'assayData' is not an expected DIA-NN report table ",
##              "output. This function expects the main output file as ",
##              "described here: https://github.com/vdemichev/DiaNN#main-output-reference")
##     if (!quantCols %in% colnames(assayData))
##         stop("'", quantCols, "' not found in 'assayData'")
##     if (!runCol %in% colnames(colData))
##         stop("'colData' must contain a column named 'colRun' that provides ",
##              "a link to the 'File.Name' column in 'assayData'")
##     if (multiplexing == "none" && !is.null(extractedData))
##         stop("Providing 'extractedData' for label-free experiments ",
##              "('multiplexed == \"none\"') is not expected. Open an ",
##              "issue if you need this feature: ",
##              "https://github.com/UCLouvain-CBIO/scp/issues/new/")
##     .checkDiannArgumentsDots(multiplexing, ...)
## }

## Internal function that adapts the dots arguments (that will be used
## by `readSCP()`) depending on the multiplexing approach used.
## .checkDiannArgumentsDots <- function(multiplexing, ...) {
##     suppArgs <- list(...)
##     if (multiplexing == "mTRAQ") {
##         suppArgs$sep <- "."
##     } else if (multiplexing == "none") {
##         suppArgs$sep <- ""
##         suppArgs$suffix <- ""
##     } else {
##         stop("The '", multiplexing, "' multiplexing strategy is not ",
##              "implemented. Raise an issue if you need this feature: ",
##              "https://github.com/UCLouvain-CBIO/scp/issues/new/choose")
##     }
##     suppArgs
## }

## (Only for mTRAQ multiplexing!) Internal function that extracts the
## mTRAQlabels from the peptide sequence, removes the mTRAQ annotation
## from the precursor ID, identifies constant columns within precursor
## and puts the quantification data for different mTRAQ labels in
## separate columns (wide format).
.formatMtraqReportData <- function(assayData, colData, quantCols, runCol) {
    assayData$Label <-
        sub("^.*[Q-](\\d).*$", "\\1", assayData$Modified.Sequence)
    assayData$Precursor.Id <-
        gsub("\\(mTRAQ.*?\\)", "(mTRAQ)", assayData$Precursor.Id)
    ## .checkLabelsInColData(colData, assayData)
    idCols <- .findPrecursorVariables(assayData,
                                      precursorId = "Precursor.Id",
                                      runCol = runCol)
    ans <- pivot_wider(
        assayData, id_cols = all_of(idCols),
        names_from = Label,
        values_from = all_of(quantCols)
    )
    list(assayData = ans,
         quantCols = setdiff(colnames(ans), colnames(assayData)))
}

## Internal function that identifies which variables in the report
## data are constant within each precursor (with each run).
.findPrecursorVariables <- function(assayData, precursorId, runCol) {
    precIds <- paste0(assayData[[precursorId]], assayData[[runCol]])
    nUniqueIds <- length(unique(precIds))
    nLevels <- sapply(colnames(assayData), function(x) {
        nrow(unique(assayData[, c(precursorId, runCol, x)]))
    })
    names(nLevels)[nLevels == nUniqueIds]
}

## Internal function that ensures that the assayData and the
## colData are correctly linked.
## .checkLabelsInColData <- function(colData, assayData) {
##     if (!"Label" %in% colnames(colData))
##         stop("'colData' must contain a column named 'Label' that ",
##              "provides the mTRAQ reagent used to label the ",
##              "samples and/or single cells.")
##     if (any(mis <- !colData$Label %in% assayData$Label)) {
##         stop("Some labels from 'colData$Label' were not found as",
##              "part of the mTRAQ labels found in ",
##              "'assayData$Modified.Sequence': ",
##              paste0(unique(colData$Label[mis]), collapse = ", "))
##     }
##     NULL
## }

## Internal function that adds the extractedData to a QFeatures
## object. The functions first converts the extractedData to a
## SummarizedExperiment objects and subsets the SCE for the set of
## shared samples. The added assay is automatically linked (using
## AssayLinks) to the assayData.
## Developer's note: the function assumes that DIA-NN creates sample
## names in the extracted data by appending the labels to the run
## names
## @param object A QFeatures object containing DIA-NN report data, as
##     generated by readQFeatures.
## @param extractedData A data.frame or any object that can be coerced
##     to a data.frame that contains the data from the
##     `*_ms1_extracted.tsv` file generated by DIA-NN.
.addDiannExtractedData <- function(object, extractedData) {
    quantColPattern <- paste0(unique(object$Label), "$", collapse = "|")
    quantCols <- grep(quantColPattern, colnames(extractedData))
    extractedData <- readSummarizedExperiment(
        extractedData, quantCols = quantCols, fnames = "Precursor.Id"
    )
    extractedData <- .keepSharedSamples(extractedData, object)
    object <- addAssay(object, extractedData, name = "Ms1Extracted")
    addAssayLink(
        object,
        from = grep("Ms1Extracted", names(object), invert = TRUE),
        to = "Ms1Extracted",
        varFrom = rep("Precursor.Id", length(names(object)) - 1),
        varTo = "Precursor.Id"
    )
}

## Internal functions that subsets the extractedData to keep only
.keepSharedSamples <- function(extractedData, object) {
    cnames <- unique(unlist(colnames(object)))
    if (any(mis <- !cnames %in% colnames(extractedData)))
        stop("Some columns present in assayData are not found in ",
             "extracted data", paste0(cnames[mis], collapse = ", "),
             "\nAre you sure the two tables were generated from ",
             "the same experiment?")
    extractedData[, cnames]
}
