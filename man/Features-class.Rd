% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Features-class.R, R/Features-constructors.R
\docType{methods}
\name{Features}
\alias{Features}
\alias{Features-class}
\alias{class:Features}
\alias{dims,Features-method}
\alias{dim,Features-method}
\alias{sampleNames,Features-method}
\alias{sampleNames<-,Features,character-method}
\alias{colData,Features-method}
\alias{colData<-,Features,DataFrame-method}
\alias{featureVariables,Features,missing-method}
\alias{featureVariables,Features,numeric-method}
\alias{featureVariables,Features,character-method}
\alias{features,Features,missing-method}
\title{Quantitative MS Features}
\usage{
\S4method{dims}{Features}(x)

\S4method{dim}{Features}(x)

\S4method{sampleNames}{Features}(object)

\S4method{sampleNames}{Features,character}(object) <- value

\S4method{colData}{Features}(x)

\S4method{colData}{Features,DataFrame}(x) <- value

\S4method{featureVariables}{Features,missing}(x, i, ...)

\S4method{featureVariables}{Features,numeric}(x, i, ...)

\S4method{featureVariables}{Features,character}(x, i, ...)

\S4method{features}{Features,missing}(x, i, ...)

Features(..., colData = NULL, metadata = list())
}
\arguments{
\item{x}{An instance of class \code{Features}.}

\item{object}{An instance of class \code{Features}.}

\item{value}{The replacement value.}

\item{i}{A \code{character(1)} or \code{numeric(1)} for subsetting.}

\item{...}{One or multiple [FeatureSet] instances passed to the
`Features` constructor.}

\item{colData}{A `DataFrame` with column (sample annotations).}

\item{metadata}{A `list()` with arbitrary object annotations.}
}
\value{
A new instance of class `Features`.
}
\description{
Conceptually, a \code{Features} object holds a set of \code{matrix} (or
\code{array}) elements containing quantitative data. The number of
columns (samples) are always the same across the matrices, but the
number of rows (features) can vary. Each one of these matrices has
a set of feature annotations (encoded as \code{DataFrame} objects), that
have the same number of rows as the assay matrix their are
associated to, and an arbitrary number of columns (feature
variables). Such a matrix and feature annotation pair is called a
\link{FeatureSet}. In addition, a \code{Features} object also uses a single
\code{DataFrame} to annotate the samples (columns) represented in all
the matrices.
}
\details{
A typical use case for such \code{Features} object is to represent
quantitative proteomics (or metabolomics) data, where different
assays represent quantitation data at the PSM (the main assay),
peptide and protein level, and where peptide values are computed
from the PSM data, and the protein-level data is calculated based
on the peptide-level values.

The largest \link{FeatureSet} (the one with the highest number of
features) is considered the main assay, from which the other ones
are derived by aggregating/combining several rows into a single
one.

The recommended way to create \code{Features} objects is the use the
\code{readFeatures()} function, that creates an instance from tabular
data. The \code{Features} constructor can be used to create objects
from their bare parts.  It is the user's responsability to make
sure that these match the class validity requirements.

A \code{Features} instance must comply with the following requirements:
\itemize{
\item The features are stored as \link{FeatureSet} instances, and each
\link{FeatureSet} has the same number of columns.
\item The number of rows and the names of \code{colData} match the number
and names of the samples (columns) in the \link{FeatureSet}s.
\item General metadata about the object itself is provided in the
\code{metadata} list, which can be empty.
}

In the usage section, the respective arguments correspond to:
}
\section{Accessors}{


The following accessors, inheritied from \link{SimpleList} are
available:
\itemize{
\item \code{length(x)}: returns the number of \link{FeatureSet} instances in
\code{x}'s \link{FeatureSet}s.
\item \code{names(x)}, \code{names(x) <- value}: gets or sets the assays
optional names of the \link{FeatureSet} instances. \code{value} is a
\code{character} of length equal to \code{length(x)}.
\item \code{dims(x)}: returns the dimensions of all \link{FeatureSet}'s assays.
\item \code{dim(x)}: returns the dimensions of the largest assay.
\item \code{isEmpty(x)}: returns \code{TRUE} for an object without any
\link{FeatureSet}s, \code{FALSE} otherwise.
\item \code{metadata(x)}, \code{metadata(x) <- value}: gets and sets the
object's global metadata. \code{value} must be a \code{list}.
\item \code{x[[i]]}, \code{x[[i]] <- value}: gets and sets a single \link{FeatureSet}
element, where \code{i} is either a \code{numeric(1)} or a
\code{character(1)}. \code{value} must be of class \code{FeatureSet}.
\item \code{x[i]}, \code{x[i] <- value}: gets the list of \link{FeatureSet} instances
defined the \code{numeric} or \code{character} \code{i}. Can also be used to
replace the the subset of \link{FeatureSet} elements with a new
\link{Features} \code{values} of matching samples.
}

The following accessors are also available.
\itemize{
\item \code{sampleNames(object)}, \code{sampleNames(x) <- value}: gets and sets
the samples names. \code{value} must be a \code{character} of appropriate
length.
\item \code{colData(x)}, \code{colData(x) <- value}: gets or sets the
columns/samples metadata.\code{value} must be a \code{DataFrame}
object. Row names of \code{value} match the existing column names of
the assays.
\item \code{featureVariables(x)}: gets the list of feature variables, where
each element of the list is a \code{character} of names for the
corresponding \link{FeatureSet}.
\item \code{featureVariables(object, i)}: a convenient alternative (to
\code{featureVariables(x)[[i]]}) to get the \code{i}th featureData
element.
}
}

\examples{

## An empty Features object

Features()

## Creating a Features object manually

m1 <- matrix(1:40, ncol = 4)
m2 <- matrix(1:16, ncol = 4)
sample_names <- paste0("S", 1:4)
colnames(m1) <- colnames(m2) <- sample_names
rownames(m1) <- letters[1:10]
rownames(m2) <- letters[23:26]

df1 <- DataFrame(Fa = 1:10, Fb = letters[1:10],
                 row.names = letters[1:10])
df2 <- DataFrame(row.names = letters[23:26])

fs1 <- FeatureSet(m1, df1)
fs1 

fs2 <- FeatureSet(m2, df2)
fs2

fts1 <- Features(fs1, fs2,
                 colData = DataFrame(Var = rnorm(4),
                                     row.names = sample_names))
fts1

## Creating a Features object from a data.frame
data(hlpsms)
fts2 <- readFeatures(hlpsms, ecol = 1:10, name = "psms")
fts2

features(fts2)
fts2[[1]]
fts2[["psms"]]
}
\author{
Laurent Gatto
}
