##' @title  Read DIA-NN output as a QFeatures objects
##'
##' @description
##'
##' This function takes the output tables from DIA-NN and converts them
##' into a `QFeatures` object.
##'
##' @param assayData A `data.frame` or any object that can be coerced
##'     to a data.frame that contains the data from the `Report.tsv`
##'     file generated by DIA-NN.
##'
##' @param colData A `data.frame` or any object that can be coerced to
##'     a `data.frame`. `colData` is expected to contains all the
##'     sample annotations. We require the table to contain a column
##'     called `File.Name` that links to the `File.Name` in the DIA-NN
##'     report table. If `multiplexing = "mTRAQ"`, we require a second
##'     column called `Label` that links the label to the sample (the
##'     labels identified by DIA-NN can be retrieved from `Modified
##'     Sequence` column in the report table).
##'
##' @param extractedData A data.frame or any object that can be
##'     coerced to a data.frame that contains the data from the
##'     `*_ms1_extracted.tsv` file generated by DIA-NN. This argument
##'     is optional and is currently only applicable for mTRAQ
##'     multiplexed experiments where DIA-NN was run using the
##'     `plexdia` module.
##'
##' @param quantCols A `character(1)` indicating which column in
##'     `assayData` contains the quantitative information. Default is
##'     `"Ms1.Area"`.
##'
##' @param multiplexing A `character(1)` indicating the type of
##'     multiplexing used in the experiment. Provide `"none"` if the
##'     experiment is label-free (default). Alternative options are:
##'     `"mTRAQ"`.
##'
##' @param ecol Same as `quantCols` for the single-set case. Available
##'     for backwards compatibility. Default is `NULL`. If both `ecol`
##'     and `colData` are set, an error is thrown.
##'
##' @param ... Further arguments passed to [readQFeatures()].
##'
##' @return An instance of class `QFeatures`. The quantiative data of
##'     each acquisition run is stored in a separate set as a
##'     `SummarizedExperiment` object.
##'
##'
##' @seealso
##'
##' - The [readQFeatures()] function to import other quantitative
##'   data.
##'
##' @author Laurent Gatto, Christophe Vanderaa
##'
##' @importFrom tidyr pivot_wider
##' @importFrom tidyselect all_of
##'
##' @export
##'
##' @examples
##'
##' ## x <- read.delim(MsDataHub::benchmarkingDIA.tsv())
##' ## fix file names
##' ## x[[1]] <- sub("^.+raw-data\\\\", "", x[[1]])
##' ## cd <- data.frame(File.Name = unique(x[[1]]))
##' ## readQFeaturesFromDIANN(colData = cd, assayData = x)
readQFeaturesFromDIANN <- function(assayData, colData, extractedData = NULL,
                                   quantCols = "Ms1.Area", multiplexing = "none",
                                   ecol = NULL,
                                   ...) {
    suppArgs <- .checkDiannArguments(
        colData, assayData, extractedData, ecol, multiplexing, ...
    )
    if (multiplexing == "mTRAQ") {
        assayData <- .formatMtraqReportData(assayData, colData, ecol)
    } else if (multiplexing == "none") {
        colData$Label <- ecol
    }
    allArgs <- c(suppArgs, list(
        assayData = assayData, colData = colData,
        runCol = "File.Name", channelCol = "Label"
    ))
    out <- do.call(readQFeatures, allArgs)
    if (!is.null(extractedData)) {
        out <- .addDiannExtractedData(out, extractedData)
    }
    out
}

## Internal function that checks whether the provided arguments match
## the expected input that is generated by DIA-NN.
## Parameter description is the same as for `readSCPfromDIANN()`
.checkDiannArguments <- function(colData, assayData, extractedData,
                                 ecol, multiplexing, ...) {
    diannReportCols <- c("File.Name", "Precursor.Id", "Modified.Sequence")
    if (!all(diannReportCols %in% colnames(assayData)))
        stop("'assayData' is not an expected DIA-NN report table ",
             "output. This function expects the main output file as ",
             "described here: https://github.com/vdemichev/DiaNN#main-output-reference")
    if (!ecol %in% colnames(assayData))
        stop("'", ecol, "' not found in 'assayData'")
    if (!"File.Name" %in% colnames(colData))
        stop("'colData' must contain a column named 'File.Name' that provides ",
             "a link to the 'File.Name' column in 'assayData'")
    if (multiplexing == "none" && !is.null(extractedData))
        stop("Providing 'extractedData' for label-free experiments ",
             "('multiplexed == \"none\"') is not expected. Raise an ",
             "issue if you need this feature: ",
             "https://github.com/UCLouvain-CBIO/scp/issues/new/choose")
    .checkDiannArgumentsDots(multiplexing, ...)
}

## Internal function that adapts the dots arguments (that will be used
## by `readSCP()`) depending on the multiplexing approach used.
.checkDiannArgumentsDots <- function(multiplexing, ...) {
    suppArgs <- list(...)
    if (multiplexing == "mTRAQ") {
        suppArgs$sep <- "."
    } else if (multiplexing == "none") {
        suppArgs$sep <- ""
        suppArgs$suffix <- ""
    } else {
        stop("The '", multiplexing, "' multiplexing strategy is not ",
             "implemented. Raise an issue if you need this feature: ",
             "https://github.com/UCLouvain-CBIO/scp/issues/new/choose")
    }
    suppArgs
}

## (Only for mTRAQ multiplexing!) Internal function that extracts the
## mTRAQlabels from the peptide sequence, removes the mTRAQ annotation
## from the precursor ID, identifies constant columns within precursor
## and puts the quantification data for different mTRAQ labels in
## separate columns (wide format).
.formatMtraqReportData <- function(assayData, colData, ecol) {
    assayData$Label <-
        sub("^.*[Q-](\\d).*$", "\\1", assayData$Modified.Sequence)
    assayData$Precursor.Id <-
        gsub("\\(mTRAQ.*?\\)", "(mTRAQ)", assayData$Precursor.Id)
    .checkLabelsInColData(colData, assayData)
    idCols <- .findPrecursorVariables(assayData)
    pivot_wider(
        assayData, id_cols = all_of(idCols),
        names_from = "Label", values_from = all_of(ecol)
    )
}

## Internal function that identifies which variables in the report
## data are constant within each precursor (with each run).
.findPrecursorVariables <- function(assayData) {
    precIds <- paste0(assayData$Precursor.Id, assayData$File.Name)
    nUniqueIds <- length(unique(precIds))
    nLevels <- sapply(colnames(assayData), function(x) {
        nrow(unique(assayData[, c("Precursor.Id", "File.Name", x)]))
    })
    names(nLevels)[nLevels == nUniqueIds]
}

## Internal function that ensures that the assayData and the
## colData are correctly linked.
.checkLabelsInColData <- function(colData, assayData) {
    if (!"Label" %in% colnames(colData))
        stop("'colData' must contain a column named 'Label' that ",
             "provides the mTRAQ reagent used to label the ",
             "samples and/or single cells.")
    if (any(mis <- !colData$Label %in% assayData$Label)) {
        stop("Some labels from 'colData$Label' were not found as",
             "part of the mTRAQ labels found in ",
             "'assayData$Modified.Sequence': ",
             paste0(unique(colData$Label[mis]), collapse = ", "))
    }
    NULL
}

## Internal function that adds the extractedData to a QFeatures
## object. The functions first converts the extractedData to a
## SummarizedExperiment objects and subsets the SCE for the set of
## shared samples. The added assay is automatically linked (using
## AssayLinks) to the assayData.
## Developer's note: the function assumes that DIA-NN creates sample
## names in the extracted data by appending the labels to the run
## names
## @param object A QFeatures object containing DIA-NN report data, as
##     generated by readQFeatures.
## @param extractedData A data.frame or any object that can be coerced
##     to a data.frame that contains the data from the
##     `*_ms1_extracted.tsv` file generated by DIA-NN.
.addDiannExtractedData <- function(object, extractedData) {
    quantColPattern <- paste0(unique(object$Label), "$", collapse = "|")
    quantCols <- grep(quantColPattern, colnames(extractedData))
    extractedData <- readSummarizedExperiment(
        extractedData, ecol = quantCols, fnames = "Precursor.Id"
    )
    extractedData <- .keepSharedSamples(extractedData, object)
    object <- addAssay(object, extractedData, name = "Ms1Extracted")
    addAssayLink(
        object,
        from = grep("Ms1Extracted", names(object), invert = TRUE),
        to = "Ms1Extracted",
        varFrom = rep("Precursor.Id", length(names(object)) - 1),
        varTo = "Precursor.Id"
    )
}

## Internal functions that subsets the extractedData to keep only
.keepSharedSamples <- function(extractedData, object) {
    cnames <- unique(unlist(colnames(object)))
    if (any(mis <- !cnames %in% colnames(extractedData)))
        stop("Some columns present in assayData are not found in ",
             "extracted data", paste0(cnames[mis], collapse = ", "),
             "\nAre you sure the two tables were generated from ",
             "the same experiment?")
    extractedData[, cnames]
}
