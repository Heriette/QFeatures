% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/readQFeatures.R
\name{readQFeatures}
\alias{readQFeatures}
\alias{readSummarizedExperiment}
\alias{readQFeatures,data.frame,data.frame}
\alias{readQFeatures,data.frame,vector}
\alias{readQFeatures,missing,vector}
\title{QFeatures from tabular data}
\usage{
readSummarizedExperiment(
  assayData,
  quantCols = NULL,
  fnames = NULL,
  ecol = NULL,
  ...
)

readQFeatures(
  assayData,
  colData = NULL,
  quantCols = NULL,
  runCol = NULL,
  name = "quants",
  removeEmptyCols = FALSE,
  verbose = TRUE,
  ecol = NULL,
  ...
)
}
\arguments{
\item{assayData}{A \code{data.frame}, or any object that can be coerced
into a \code{data.frame}, holding the quantitative assay. For
\code{readSummarizedExperiment()}, this can also be a
\code{character(1)} pointing to a filename.}

\item{quantCols}{A \code{numeric()}, \code{logical()} or \code{character()}
defining the columns of the \code{assayData} that contain the
quantitative data. This information can also be defined in
\code{colData}.}

\item{fnames}{For the single- and multi-set cases, an optional
\code{character(1)} or \code{numeric(1)} indicating the column to be
used as feature names.  Note that rownames must be unique
within \code{QFeatures} sets.}

\item{ecol}{Same as \code{quantCols}. Available for backwards
compatibility. Default is \code{NULL}. If both \code{ecol} and \code{colData}
are set, an error is thrown.}

\item{...}{Further arguments that can be passed on to \code{\link[=read.csv]{read.csv()}}
except \code{stringsAsFactors}, which is always \code{FALSE}. Only
applicable to \code{readSummarizedExperiment()}.}

\item{colData}{A \code{data.frame} (or any object that can be coerced
to a \code{data.frame}) containing sample/column annotations,
including \code{quantCols} and \code{runCol} (see details).}

\item{runCol}{For the multi-set case, a \code{numeric(1)} or
\code{character(1)} pointing to the column of \code{assayData} (and
\code{colData}, is set) that contains the runs/batches. Make sure
that the column name in both tables are identical and
syntactically valid (if you supply a \code{character}) or have the
same index (if you supply a \code{numeric}). Note that characters
are converted to syntactically valid names using \code{make.names}}

\item{name}{For the single-set case, an optional \code{character(1)} to
name the set in the \code{QFeatures} object. Default is \code{quants}.}

\item{removeEmptyCols}{A \code{logical(1)}. If \code{TRUE}, quantitative
columns that contain only missing values are removed.}

\item{verbose}{A \code{logical(1)} indicating whether the progress of
the data reading and formatting should be printed to the
console. Default is \code{TRUE}.}
}
\value{
An instance of class \code{QFeatures} or
\code{\link[SummarizedExperiment:RangedSummarizedExperiment-class]{SummarizedExperiment::SummarizedExperiment()}}. For the
former, the quantitative sets of each run are stored in
\code{\link[SummarizedExperiment:RangedSummarizedExperiment-class]{SummarizedExperiment::SummarizedExperiment()}} object.
}
\description{
These functions convert tabular data into dedicated data
objets. The \code{\link[=readSummarizedExperiment]{readSummarizedExperiment()}} function takes a
\code{data.frame} and converts it into a \code{\link[=SummarizedExperiment]{SummarizedExperiment()}}
object.  The \code{\link[=readQFeatures]{readQFeatures()}} function takes a \code{data.frame} and
converts it into a \code{QFeatures} object (see \code{\link[=QFeatures]{QFeatures()}} for
details). Two use-cases exist here:
\itemize{
\item The single-set case will generate a \code{QFeatures} object with a
single \code{SummarizedExperiment} set containing all features of the
input table.
\item The multi-set case will generate a \code{QFeatures} object containing
multiple \code{SummarizedExperiment} sets, resulting from splitting
the input table. This multi-set case should be used when the
input table contains data from multiple runs/batches?
}
}
\details{
The single- and multi-set cases are defined by the \code{quantCols} and
\code{runCol} parameters, whether passed by the \code{colData} \code{data.frame}
and/or the \code{quantCols} and \code{runCol} arguments.
\subsection{Single-set case}{

In both single- and multi-set cases, the quantitative data
variables must be defined by the \code{quantCols} argument or
\code{quantCols} variable in \code{colData} (see single-set cases in the
example). These cases can be represented schematically as shown
below.

\if{html}{\out{<div class="sourceCode">}}\preformatted{|------+----------------+-----------|
| cols | quantCols 1..N | more cols |
| .    | ...            | ...       |
| .    | ...            | ...       |
| .    | ...            | ...       |
|------+----------------+-----------|
}\if{html}{\out{</div>}}

The single-set case is defined by the absence of any \code{runCol}
input (see next section).
}

\subsection{Multi-set case}{

A run/batch variable is required to import multi-set data. It can
either be defined as a \code{runCol} argument only, or a \code{runCol}
argument and a \code{runCol} variable in \code{colData} (see multi-set cases
in the example). These cases can be represented schematically as
shown below.

\if{html}{\out{<div class="sourceCode">}}\preformatted{|--------+------+----------------+-----------|
| runCol | cols | quantCols 1..N | more cols |
|   1    | .    | ...            | ...       |
|   1    | .    | ...            | ...       |
|--------+------+----------------+-----------|
|   2    | .    | ...            | ...       |
|--------+------+----------------+-----------|
|   .    | .    | ...            | ...       |
|--------+------+----------------+-----------|
}\if{html}{\out{</div>}}

Whe using a \code{colData} \code{data.frame} as input, it must contain at
least \code{quantCols} and \code{runCol} (in the multi-set case)
variables. Additional sample annotations are desirable, and the
reason such a \code{colData} can be passed directly to populate the
\code{colData} slot of the returned object. When using the \code{quantCols}
and \code{runCol} only, the \code{colData} slot contains zero
columns/variables.
}
}
\examples{

######################################
## Single-set case.

## Load a data.frame with PSM-level data
data(hlpsms)
hlpsms[1:10, c(1, 2, 10:11, 14, 17)]

## Create a QFeatures object with a single psms set
qf1 <- readQFeatures(hlpsms, quantCols = 1:10, name = "psms")
qf1
colData(qf1)

######################################
## Single-set case using a data.frame.

(coldat <- data.frame(var = rnorm(10),
                      quantCols = names(hlpsms)[1:10]))
qf2 <- readQFeatures(hlpsms, colData = coldat)
qf2
colData(qf2)

######################################
## Multi-set case

## Let's simulate 3 different files/batches for that same input
## data.frame, and define a colData data.frame.

hlpsms$file <- paste0("File", sample(1:3, nrow(hlpsms), replace = TRUE))
hlpsms[1:10, c(1, 2, 10:11, 14, 17, 29)]

qf3 <- readQFeatures(hlpsms, quantCols = 1:10, runCol = "file")
qf3
colData(qf3)


######################################
## Multi-set case using a data.frame

(coldat <- data.frame(runCol = rep(paste0("File", 1:3), each = 10),
                      var = rnorm(10),
                      quantCols = names(hlpsms)[1:10]))
qf4 <- readQFeatures(hlpsms, colData = coldat, runCol = "file")
qf4
colData(qf4)
}
\seealso{
\itemize{
\item The \code{QFeatures} (see \code{\link[=QFeatures]{QFeatures()}}) class to read about how to
manipulate the resulting \code{QFeatures} object.
\item The \code{\link[=readQFeaturesFromDIANN]{readQFeaturesFromDIANN()}} function to import DIA-NN
quantitative data.
}
}
\author{
Laurent Gatto, Christophe Vanderaa
}
